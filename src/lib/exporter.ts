/**
 * Export functionality - package an agent for distribution
 */

import fs from 'fs-extra';
import path from 'path';
import * as tar from 'tar';
import type { PorterManifest, ExportOptions, ExportResult } from '../types.js';
import { loadManifest, validateManifest } from './manifest.js';
import { scanWorkspace, checkForSecrets } from './scanner.js';

/**
 * Export an agent workspace to a portable package
 */
export async function exportAgent(
  workspacePath: string,
  options: ExportOptions = {}
): Promise<ExportResult> {
  const errors: string[] = [];

  // Resolve workspace path
  const resolvedPath = path.resolve(workspacePath);

  // Load manifest
  const manifest = await loadManifest(resolvedPath);
  if (!manifest) {
    return {
      success: false,
      files: [],
      errors: ['No porter.yaml found. Run `openclaw-porter init` first.'],
    };
  }

  // Validate manifest
  const validation = validateManifest(manifest);
  if (!validation.valid) {
    return {
      success: false,
      files: [],
      errors: validation.errors,
    };
  }

  // Scan files
  const scanResult = await scanWorkspace(resolvedPath, manifest);

  if (scanResult.warnings.length > 0 && !options.force) {
    errors.push(...scanResult.warnings.map((w) => `Warning: ${w}`));
  }

  // Check for secrets
  const leaks = await checkForSecrets(resolvedPath, scanResult.files);
  if (leaks.length > 0 && !options.force) {
    return {
      success: false,
      files: [],
      errors: [
        'Potential secrets detected! Use --force to override:',
        ...leaks.map((l) => `  ${l.file}:${l.line} - ${l.match}`),
      ],
    };
  }

  // Generate USER.md.template if USER.md exists
  const userMdPath = path.join(resolvedPath, 'USER.md');
  if (await fs.pathExists(userMdPath)) {
    const userTemplate = await generateUserTemplate(userMdPath);
    const templatePath = path.join(resolvedPath, 'USER.md.template');
    await fs.writeFile(templatePath, userTemplate);
    scanResult.files.push('USER.md.template');
  }

  // Dry run - just report what would be exported
  if (options.dryRun) {
    return {
      success: true,
      files: scanResult.files,
      outputPath: undefined,
    };
  }

  // Determine output path
  const outputDir = options.output || path.join(resolvedPath, 'dist');
  await fs.ensureDir(outputDir);

  const archiveName = `${manifest.name}-${manifest.version}.tar.gz`;
  const archivePath = path.join(outputDir, archiveName);

  // Create tarball
  await tar.create(
    {
      gzip: true,
      file: archivePath,
      cwd: resolvedPath,
      prefix: manifest.name,
    },
    scanResult.files
  );

  // Generate README if it doesn't exist
  const readmePath = path.join(resolvedPath, 'README.md');
  if (!(await fs.pathExists(readmePath))) {
    const readme = generateReadme(manifest);
    await fs.writeFile(readmePath, readme);
  }

  return {
    success: true,
    outputPath: archivePath,
    files: scanResult.files,
  };
}

/**
 * Generate a USER.md.template from existing USER.md
 */
async function generateUserTemplate(userMdPath: string): Promise<string> {
  const content = await fs.readFile(userMdPath, 'utf-8');

  // Replace specific values with placeholders
  let template = content
    // Replace names (basic heuristic)
    .replace(/\*\*Name:\*\* .+/g, '**Name:** {{YOUR_NAME}}')
    .replace(/- \*\*Name:\*\* .+/g, '- **Name:** {{YOUR_NAME}}')
    // Replace timezone
    .replace(/\*\*Timezone:\*\* .+/g, '**Timezone:** {{YOUR_TIMEZONE}}')
    // Replace location
    .replace(/\*\*Location:\*\* .+/g, '**Location:** {{YOUR_LOCATION}}')
    // Replace contact info
    .replace(/\*\*Telegram:\*\* .+/g, '**Telegram:** {{YOUR_TELEGRAM}}')
    .replace(/\*\*Twitter:\*\* .+/g, '**Twitter:** {{YOUR_TWITTER}}')
    .replace(/\+1[\d\s-]+/g, '{{YOUR_PHONE}}');

  // Add header comment
  template =
    `<!-- 
  USER.md.template - Fill in your details below
  This file was generated by openclaw-porter
  Rename to USER.md after filling in your information
-->\n\n` + template;

  return template;
}

/**
 * Generate a README for the agent package
 */
function generateReadme(manifest: PorterManifest): string {
  const skills = [
    ...(manifest.skills?.bundled?.map((s) => path.basename(s.path)) || []),
    ...(manifest.skills?.external?.map((s) => s.name) || []),
  ];

  const envVars = [...(manifest.env?.required || []), ...(manifest.env?.optional || [])];

  return `# ${manifest.name}

${manifest.description}

## Installation

\`\`\`bash
openclaw-porter import github:${manifest.author || 'user'}/${manifest.name}
\`\`\`

## Requirements

- Clawdbot ${manifest.engine.clawdbot}
${manifest.engine.node ? `- Node.js ${manifest.engine.node}` : ''}

${
  envVars.length > 0
    ? `## Environment Variables

${manifest.env?.required?.map((v) => `- \`${v}\` (required)`).join('\n') || ''}
${manifest.env?.optional?.map((v) => `- \`${v}\` (optional)`).join('\n') || ''}
`
    : ''
}
${
  skills.length > 0
    ? `## Skills

${skills.map((s) => `- ${s}`).join('\n')}
`
    : ''
}
${manifest.tags?.length ? `## Tags\n\n${manifest.tags.map((t) => `\`${t}\``).join(' ')}\n` : ''}
---

*Packaged with [openclaw-porter](https://github.com/Purple-Horizons/openclaw-porter)*
`;
}
